function neural = buildSimulatedDataset(stim,noiseFolder,newDatasetFolder,model,snr,nSub2generate,varargin)
%BUILDSIMULATEDDATASET  Generates a simulated EEG dataset
%   NEURAL = BUILDSIMULATEDDATASET(STIMFOLDER,NOISEFOLDER,NEWDATASETFOLDER,MODEL,SNR)
%   Let's consider a stimulus file, dataStim.mat in 'stimFolder' and a TRF
%   'model'. This function generates a simulated neural dataset by
%   convolving the stimulus feature with the given model, which represents
%   the impulse response of the system. The function also adds noise to the
%   resulting signal. To do so, it loads a noise signal from the
%   'noiseFolder'. Typically, this noise signal is some existing neural
%   signal (e.g., EEG), unprocessed (raw signal). The noise signal can be
%   from a dataset using the same exact stimuli (as time and trials are
%   randomised via circular shifts and a shuffling of the trial indices; in
%   addition, a time-reversing option is available - see the parameter
%   'timeReverseNoise'). The noise signal can also be from any other
%   dataset. In that case, we advise selecting a noise dataset with trials
%   at least as long as the stimulus features to avoid discontinuities in
%   the neural noise signal. 'snr' indicates the signal to noise ratio of
%   that linear combination between simulated ground-truth and recorded EEG noise.
%
%   STIMFOLDER indicates the folder of the stimulus features
%       saved according to the CND data structure.
%   NOISEFOLDER indicates the folder of the neural noise signal
%       saved according to the CND data structure.
%   NEWDATASETFOLDER indicates the folder where the simulated dataset will
%       be saved as a CND
%
%   Note:
%   STIMFOLDER can potentially be the same as NOISEFOLDER, as the neural
%   data in the latter is selected after shuffling trials. However, please
%   be aware that this can be problematic in case of repeated stimuli, as
%   the shuffling operation is not enough to guarantee that stimulus
%   and neural signals are not matched. Time-reversing the noise signal is
%   also provided as an option. 
%   If NOISEFOLDER is different from STIMFOLDER, the noise will be
%   concatenated for different trials to match the length of the stimulus
%   features. We advise selecting a noise dataset with long trials to
%   keep these discontinuities at a minimum, or avoid them altogether.
%
%
%   MODEL is a structure indicating the neural impulse response to the
%       stimulus that will be used for generating the ground-truth neural
%       signal. MODEL can be a TRF derived from real data or even a
%       completely artificial TRF. MODEL should include the fields:
%       'w'         -- normalized model weights (xvar-by-nlag-by-yvar)
%       'b'         -- normalized bias term (1-by-nlag-by-yvar)
%       't'         -- time lags (ms)
%       'fs'        -- sample rate (Hz)
%       'Dir'       -- direction of causality (forward=1, backward=-1)
%       'type'      -- type of model (multi-lag, single-lag)
%
%   SNR  A scalar specifying the signal-to-noise ratio when combining the
%        ground-truth signal and the noise signal. SNR should be expressed
%        as a log10 value
%        simulatedEEG = (10^snr)*groundTruthEEG + noiseEEG
%
%   NSUB2GENERATE  A scalar indicating how many subjects should be
%                  generated by this simulation
%
%   NEURAL = BUILDSIMULATEDDATASET(...) returns the generated neural data. The output
%   variable 'neural' is stored according to the CND data structure for
%   neural signals.
%
%   [...] = BUILDSIMULATEDDATASET(...,'PARAM1',VAL1,'PARAM2',VAL2,...) specifies
%   additional parameters and their values. Valid parameters are the
%   following:
%
%       Parameter          Value
%       'timeReverseNoise' if this flag is true the neural signal noise will be
%                          time-reversed
%       'outputNoiseSignal' if this flag is true the neural noise signal
%                          will be included in the output structure
%       'outputGroundTruth' if this flag is true the ground-truth signal
%                          will be included in the output structure
%       'nSumsNoise'       each noise signal will be generates as the sum
%                          of 'nSumsNoise' original neural signals
%                          (default: 3)
%       'verbose'   A numeric or logical specifying whether to execute in
%                   verbose mode: pass in 1 for verbose mode (default), or
%                   0 for non-verbose mode.
%
%   CNSP-initiative: https://cnspworkshop.net/
%   SEE ALSO:
%       mTRF-Toolbox: https://github.com/mickcrosse/mTRF-Toolbox
%
%   References:
%      [1] Crosse MC, Di Liberto GM, Bednar A, Lalor EC (2016) The
%          multivariate temporal response function (mTRF) toolbox: a MATLAB
%          toolbox for relating neural signals to continuous stimuli. Front
%          Hum Neurosci 10:604.
%
%   EXAMPLE:
%   Generate Simulated Speech listening EEG
% 
%   stimFolder = '../datasets/LalorNatSpeech/dataCND/';
%   noiseFolder = '../datasets/LalorNatSpeech/dataCND/';
%   newDatasetFolder = '../datasets/ToyNatSpeech/'; % new folder
%   snr = -4;
%   load('CNSP2023_toyExperiment_fTRF_NaturalSpeech.mat')
%   avgModel = mTRFmodelAvg(modelAll);
%   nSubs2gen = 5;
%   eegSimulated = buildSimulatedDataset(stimFolder,noiseFolder,newDatasetFolder,avgModel,snr,nSubs2gen,...
%     'timeReverseNoise',true,'outputGroundTruth',false,'outputNoiseSignal',false,'verbose',true,...
%     'save2file',true,'nSumsNoise',5);
%


%   Authors: Giovanni Di Liberto <diliberg@tcd.ie>
%   Copyright 2023 Di Liberto Lab, Trinity College Dublin.

addpath libs/cnsp_utils
addpath libs/cnsp_utils/cnd
addpath libs/mTRF-Toolbox_v2/mtrf

% Parse input arguments
arg = parsevarargin(varargin);

% Verbose mode
if arg.timeReverseNoise
    timeReverseNoise = 1;
else
    timeReverseNoise = 0;
end

% Verbose mode
if arg.verbose
    verbose = 1;
else
    verbose = 0;
end

% Converting snr value from log10 to linear
if isscalar(snr)
    snr = 10^snr;
else
    disp('Error: snr should be a single numerical value')
    return
end


% Creating Output folder
mkdir(newDatasetFolder)
mkdir([newDatasetFolder,'dataCND/'])

% [stimfolder,~,~] = fileparts(stim);
if isfield(model, 'chanlocs')
    chanlocs = model.chanlocs;
else
    % subs = dir([stimfolder,'/*dataSub*.mat']);
    % load(fullfile(subs(1).folder,subs(1).name));
    % chanlocs = eeg.chanlocs;
    chanlocs = struct();
    chanlocs.labels = 1;
end

% Loading stimulus features
load(stim, 'stim') % if one dataStim only

stimIdx = 1; % 1: env; 2: word onset
if arg.stimIdx
    stimIdx = arg.stimIdx;
else
    stimIdx = 1;
end

channel = arg.channel;

save([newDatasetFolder,'dataCND/dataStim_all.mat']) % if one dataStim only

% List of EEG files
if isa(arg.noiseGen, 'function_handle')
    noiseGen = arg.noiseGen;
    
    % How many subjects we will generate
    neuralNoiseSubIdxs = 1:nSub2generate;
else
    if arg.preprocessed
        neuralDataFilenames = dir([noiseFolder,'pre_dataSub*.mat']);
    else
        neuralDataFilenames = dir([noiseFolder,'dataSub*.mat']);
    end
    nSubs = length(neuralDataFilenames);
    
    % How many subjects we will generate
    neuralNoiseSubIdxs = max(1,ceil(rand(nSub2generate,1)*nSubs));
end

if verbose
    figure('Position',[50,250,600,200]);
end
% Loading first example of eeg noise
for subNew = 1:nSub2generate                    % For each new subject

    modelTmp = model
    % Generating simulated EEG
    if ~strcmp(channel,'all')
        channel_num = find(strcmp({chanlocs.labels},channel));
        modelTmp.w = model.w(:,:,channel_num)
        modelTmp.b = model.b(:,channel_num)
    end
    groundTruthSignal = mTRFpredict(stim.data(stimIdx,:),[],modelTmp)';
    allValuesGroundTruth = groundTruthSignal{1}(:);
    for tr = 2:length(groundTruthSignal)
        allValuesGroundTruth = cat(1,allValuesGroundTruth,(groundTruthSignal{tr}(:)));
    end
    normFactorGroundTruth = std(allValuesGroundTruth);
    groundTruthSignal = cellfun(@(x) x/normFactorGroundTruth,groundTruthSignal,'UniformOutput',false);
    clear allValuesGroundTruth
    if ~isa(arg.noiseGen, 'function_handle')
        subOrig = neuralNoiseSubIdxs(subNew); % Selecting random subject
        % Loading neural data and renaming the variable (e.g., eeg, meg)
        % Typically this is neural data before preprocessing
        loadedStruct = load([noiseFolder,neuralDataFilenames(subOrig).name]);
        neural = struct2cell(loadedStruct); neural=neural{1};
        clear loadedStruct
        
        % Matching number of trials by repeating noise trials
        if size(neural.data,2)>size(stim.data,2)
            neural.data = neural.data(:,size(stim.data,2));
        elseif size(neural.data,2)<size(stim.data,2)
            while size(neural.data,2)<size(stim.data,2)
                neural.data = cat(2,neural.data,neural.data);
            end
            neural.data = neural.data(:,1:size(stim.data,2));
        end
        
        % Matching trial length
        % Repeating neural so that it's of the same length as stim
        for ccTr = 1:size(neural.data,2)
            stimLen = size(stim.data{stimIdx,ccTr},1);
            neuralLen = size(neural.data{:,ccTr},1);
            while neuralLen/neural.fs < stimLen/stim.fs
                neural.data{:,ccTr} = cat(1,neural.data{:,ccTr},neural.data{:,ccTr});
                neuralLen = size(neural.data{:,ccTr},1);
            end
            neural.data{:,ccTr} = neural.data{:,ccTr}(1:round(stimLen/stim.fs*neural.fs),:); % same length as stim
            
            % Matching number of electrodes
            if strcmp(channel,'all')
                nEl = size(model.w,3);
            else
                nEl = 1;
            end
            if  nEl < size(neural.data{:,ccTr},2)
                neural.data{:,ccTr} = neural.data{:,ccTr}(:,1:nEl);
            elseif nEl > size(neural.data{:,ccTr},2)
                while nEl > size(neural.data{:,ccTr},2)
                    neural.data{:,ccTr} = cat(2,neural.data{:,ccTr},neural.data{:,ccTr})
                end
                neural.data{:,ccTr} = neural.data{:,ccTr}(:,1:nEl);
            end
        end
        
        for ccSum = 1:arg.nSumsNoise
            % Decouple stimulus and neural signal
            % Channels, trials, and time-shifts are randomised
            for tr = 1:length(neural.data)
                % Selecting random trial
                trRnd = tr;
                while trRnd == tr
                    trRnd = max(1,ceil(rand*length(neural.data)));
                end
                % Selecting random channel
                % Selecting random circShift value
                neural.data{tr} = circshift(neural.data{tr},round(rand*size(neural.data{tr},1)));
                % Time-reverse noise
                if timeReverseNoise
                    neural.data{tr} = flip(neural.data{tr});
                end
            end
            if ccSum == 1
                noiseSignal = neural.data;
            else
                for tr = 1:length(noiseSignal)
                    noiseSignal{tr} = noiseSignal{tr} + neural.data{tr};
                end
            end
        end
    %     % Avg neural signals, not sum % unnecessary, as it is normalised
    %     % afterwards
    %     if arg.nSumsNoise>1
    %         for tr = 1:length(noiseSignal)
    %             noiseSignal{tr} = noiseSignal{tr}/arg.nSumsNoise;
    %         end
    %     end
        
        % Check sampling freq (everything will be forced to stim.fs)
        if neural.fs < stim.fs
            disp('Upsampling noise signal')
            neural.data = cellfun(@(x) resample(x,stim.fs,neural.fs,0),neural.data,'UniformOutput',false);
            neural.fs = stim.fs;
        elseif neural.fs > stim.fs
            disp('Downsampling noise signal')
            % Anti-aliasing filter
            hd = getLPFilt(neural.fs,stim.fs/2);
            neural.data = cellfun(@(x) filtfilthd(hd,x),neural.data,'UniformOutput',false);
            % Downsampling eeg
            neural.data = cellfun(@(x) resample(double(x),stim.fs,neural.fs,0),neural.data,'UniformOutput',false);
            neural.fs = stim.fs;
        end
    
        % Ensuring that stim and eeg have the same sampling frequency and number of
        % samples
        [stim,neural] = cndCheckStimNeural(stim,neural);
    
        % Normalise EEG noise and ground truth
        bandpassFilterRange = [.5,8];
        hd = getLPFilt(neural.fs,bandpassFilterRange(2));
        nd = cellfun(@(x) filtfilthd(hd,x),neural.data,'UniformOutput',false);
        hd = getHPFilt(neural.fs,bandpassFilterRange(1));
        nd = cellfun(@(x) filtfilthd(hd,x),nd,'UniformOutput',false);
        
        allValuesNeural = nd{1}(:);
    
        for tr = 2:length(nd)
            allValuesNeural = cat(1,allValuesNeural,(nd{tr}(:)));
        end
        normFactorNoise = std(allValuesNeural);
        neural.data = cellfun(@(x) x/normFactorNoise,neural.data,'UniformOutput',false);
        clear allValuesNeural
        
        % Exporting simulated dataset
        noiseSignal = neural.data;
        % Checking lengths (in case of rounding differences
        for ccTr = 1:size(neural.data,2)
            stimLen = size(stim.data{stimIdx,ccTr},1);
            neuralLen = size(neural.data{:,ccTr},1);
            minLen = min(stimLen,neuralLen);
            stim.data{stimIdx,ccTr} = stim.data{stimIdx,ccTr}(1:minLen,:);
            neural.data{:,ccTr} = neural.data{:,ccTr}(1:minLen,:);
        end 

    else
        for tr=1:length(stim.data)
            for el=1:size(model.w,3)
                noiseSignal{tr}(:, el) = noiseGen(size(groundTruthSignal{tr},1));
            end
        end
    end

    % Check TRF sampling freq (everything will be forced to stim.fs)
    if model.fs ~= stim.fs
        model.w = resample(model.w,stim.fs,model.fs,0);

        tmin = model.t(1)*stim.fs/1e3;
        tmax = model.t(end)*stim.fs/1e3;
        nLags = length(tmin:tmax);
        model.t = model.t(1):((model.t(end)-model.t(1))/(nLags-1)):model.t(end);

        % correcting possible rounding issue
        model.w(:,end+1,:) = 0;
        model.w = model.w(:,1:nLags,:); 

        model.fs = stim.fs;
    end
    if arg.outputNoiseSignal
        neural.noiseSignal       = noiseSignal;
    end
    if arg.outputGroundTruth
        neural.groundTruthSignal = groundTruthSignal;
    end
    for tr = 1:length(stim.data)
        % Checking that there is always noise (it may happen that an
        % electrode didn't work (no signal) with real recordings)
        if ~isa(arg.noiseGen, 'function_handle')
            stdNoise = std(noiseSignal{tr});
            ch2replace = stdNoise < mean(stdNoise)/10; % channels with not enough noise to replace
            goodChs = find(ch2replace==0);
            goodChs = goodChs(randperm(length(goodChs)));
            for ch = find(ch2replace)
                noiseSignal{tr}(:,ch) = noiseSignal{tr}(:,goodChs(1));
            end
        end
        try
            neural.data{tr} = snr*groundTruthSignal{tr} +  noiseSignal{tr};
        catch
            disp(size(groundTruthSignal{tr}))
            disp(size(noiseSignal{tr}))
        end
    end
    neural.SNR = snr;
    if isfield(neural, 'dataType')
        neural.dataType = ['Simulated ',neural.dataType];
    else
        neural.dataType = 'Simulated';
    end
    if isfield(neural, 'extChan')
        neural = rmfield(neural,'extChan');
    end

    if arg.verbose
        el = 1;
        subplot(1,3,1);plot(neural.data{tr}(1:min(10000,size(neural.data{tr},1)),el));title('Simulated neural signal')
        subplot(1,3,2);plot(noiseSignal{tr}(1:min(10000,size(neural.data{tr},1)),el));title('Noise signal')
        subplot(1,3,3);plot(groundTruthSignal{tr}(1:min(10000,size(neural.data{tr},1)),el));title('Ground truth')
    end
    
    if arg.save2file
        save([newDatasetFolder,'dataCND/dataSub',num2str(subNew),'.mat'],'neural') % before preprocessing
    end
end

    

function arg = parsevarargin(varargin)
%PARSEVARARGIN  Parse input arguments.
%   [PARAM1,PARAM2,...] = PARSEVARARGIN('PARAM1',VAL1,'PARAM2',VAL2,...)
%   parses the input arguments of the main function.

% Create parser object
p = inputParser;

% Boolean arguments
errorMsg = 'It must be a numeric scalar (0,1) or logical.';
validFcn = @(x) assert(x==0||x==1||islogical(x),errorMsg);
addParameter(p,'timeReverseNoise',false,validFcn); % timeReverseNoise
addParameter(p,'verbose',true,validFcn); % verbose mode
addParameter(p,'preprocessed',false,validFcn); % verbose mode
addParameter(p,'outputGroundTruth',false,validFcn); % outputGroundTruth
addParameter(p,'outputNoiseSignal',false,validFcn); % outputNoiseSignal
addParameter(p,'save2file',true,validFcn); % outputNoiseSignal

% nSumsNoise
errorMsg = 'It must be a positive integer scalar.';
validFcn = @(x) assert(isnumeric(x)&&isscalar(x),errorMsg);
addParameter(p,'nSumsNoise',3,validFcn);
addParameter(p,'stimIdx',1); % stimIdx
addParameter(p,'channel','all'); % stimIdx
addParameter(p,'noiseGen','0'); % stimIdx

% Parse input arguments
parse(p,varargin{1,1}{:});
arg = p.Results;

